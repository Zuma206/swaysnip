#!/usr/bin/env python3
# Sway Snip by Zuma206
# Licensed under the GPLv3
import subprocess
import itertools
import datetime
import shutil
import i3ipc
import sys
import os

# Check that the required dependancies are installed for a given function
def dependancies(*dependancies):
  def decorator(func_or_class):
    for dependancy in dependancies:
      if shutil.which(dependancy) is None:
        print(f"Missing dependancy: {dependancy}")
    return func_or_class
  return decorator

# Wrapper for the grim utility
@dependancies("grim")
def grim(output=None):
  output_opt = ["-o", output.name] if output != None else []
  proc = subprocess.run(["grim", *output_opt, "-"], check=True, capture_output=True)
  return proc.stdout

# Wrapper for the imv utility
@dependancies("imv")
def imv(image, fullscreen=False, wait=False):
  fullscreen_opt = ["-f"] if fullscreen else []
  proc = subprocess.Popen(["imv", *fullscreen_opt, "-"], stdin=subprocess.PIPE)
  proc.stdin.write(image)
  proc.stdin.close()
  if wait:
    proc.wait()
  return proc

# Maps a process to a context, terminating it on context exit
class ProcessContext:
  def __init__(self, proc):
    self.__proc = proc
  
  def __enter__(self):
    return self.__proc

  def __exit__(self, *_):
    return self.__proc.terminate()

# Represents crop geometry
class Geometry:
  def __init__(self, w, h, x, y):
    self.w = w
    self.h = h
    self.x = x
    self.y = y

  def scale(self, scale):
    return Geometry(
      self.w * scale, self.h * scale,
      self.x * scale, self.y * scale
    )

# Wrapper for the slurp utility
@dependancies("slurp")
def slurp():
  proc = subprocess.run(["slurp", "-f", "%w %h %x %y"], check=True, capture_output=True)
  return Geometry(*map(float, proc.stdout.decode().split()))

# Wrapper for the magick -crop option
@dependancies("magick")
def crop(image, geometry):
  geometry_opt = f"{geometry.w}x{geometry.h}+{geometry.x}+{geometry.y}"
  proc = subprocess.run(["magick", "-", "-crop", geometry_opt, "-"], input=image, check=True, capture_output=True)
  return proc.stdout

# Get's the currently focused output using sway's IPC system
def get_focused_output():
  outputs = i3ipc.Connection().get_outputs()
  return next(filter(lambda output: output.focused, outputs))

# Wrapper for the swaynag command
@dependancies("swaynag")
def sway_nag(message, actions, nag_type=None):
  button_opts = [["-z", text, f"echo {index}"] for index, text in enumerate(actions)]
  button_opts = list(itertools.chain.from_iterable(button_opts))
  nag_type_opt = ["--type", nag_type] if nag_type is not None else []
  code = subprocess.run(["swaynag", *nag_type_opt, "-m", message, *button_opts], capture_output=True).stdout.decode()
  if code == "":
    return -1
  return int(code)

# Copies to the wayland clipboard
@dependancies("wl-copy")
def wlcopy(buf, mime_type=None):
  mime_type_opt = ["-f", mime_type] if mime_type is not None else []
  subprocess.run(["wl-copy", *mime_type_opt], input=buf, check=True)

SCREENSHOT_DIR = os.path.expanduser("~/Pictures/screenshots")

# Save a screenshot to a filename based on the time it was taken
def save_screenshot(time, image):
  os.makedirs(SCREENSHOT_DIR, exist_ok=True)
  filepath = os.path.join(SCREENSHOT_DIR, time.strftime("%Y-%m-%d_%H-%M-%S-%f.png"))
  with open(filepath, "wb") as file:
    file.write(image)

# Takes a screenshot, and displays it in fullscreen
def main():
  output = get_focused_output()
  image = grim(output)
  time = datetime.datetime.now()
  with ProcessContext(imv(image, fullscreen=True)):
    geometry = slurp().scale(output.scale)
  cropped = crop(image, geometry)
  with ProcessContext(imv(cropped)):
    nag_type = sys.argv[1] if len(sys.argv) > 1 else None
    choice = sway_nag("Screenshot Taken", ["Copy", "Save"], nag_type=nag_type)
  match choice:
    case 0:
      wlcopy(cropped)
    case 1:
      save_screenshot(time, cropped)
  
if __name__ == "__main__":
  main()
